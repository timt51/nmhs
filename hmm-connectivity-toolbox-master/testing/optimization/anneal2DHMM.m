function [tr1_trained, tr2_trained, em1_trained, em2_trained, logL] = ...
         anneal2DHMM(tr1_guess, tr2_guess, em1_guess, em2_guess, seq1, seq2, logFile, varargin)
  %  args:
  %      tr1_guess and tr2_guess are conntected markov matrices
  %      em1_guess and em2_guess are markov emission matrices
  %      seq1 and seq2 are the observed emissions of the two processes being
  %          modeled
  %
  %  optargs:
  %      guess1D: if true, the 'guess' model for SA will be generated by
  %          running hmmtrain on seq1 and seq2.
  %      time_limit: time, in seconds, that the simulation will run for
  %      func_evals: maximum number of times the goal function will be evaluated
  %          before simulation terminates
  %
  %  outputs:
  %      tr1_trained and tr2_trained are connected markov matrices representing
  %          the best model found by the simulation
  %      em1_trained and em2_trained are the corresponding emission matrices

  global sa_trajectory;
  numvarargs = length(varargin);
  if numvarargs > 4
    error('anneal2DHMM:TooManyInputs', ...
          'requires at most 3 optional inputs');
  end

    
  % set defaults for optional inputs
  optargs = {true, 90000, 90000, false};

  % now put these defaults into the valuesToUse cell array,
  % and overwrite the ones specified in varargin.
  optargs(1:numvarargs) = varargin;

  % Place optional args in memorable variable names
  [guess1D, time_limit, func_evals, resume] = optargs{:};


  if guess1D
    %run 1d hmmtrain on the data
    [tr1_trained, em1_trained] = hmmtrain(seq1, mean(tr1_guess, 3), em1_guess);
    [tr2_trained, em2_trained] = hmmtrain(seq2, mean(tr2_guess, 3), em2_guess);
    %compose a 2d hmm with the results
    tr1_guess = repmat(tr1_trained, 1, 1, size(tr1_guess, 3));
    tr2_guess = repmat(tr2_trained, 1, 1, size(tr2_guess, 3));
    em1_guess = em1_trained;
    em2_guess = em2_trained;
  end

  if ~resume
    initSATrajectory();
  end
  options = saoptimset('DataType', 'custom', 'AnnealingFcn', @permute2DHMM, ...
                       'MaxFunEvals', func_evals, 'TimeLimit', time_limit, 'TolFun',1e-10);

  if(size(tr1_guess,1) >2 || size(tr2_guess, 1) > 2)
    options = saoptimset(options, 'ReannealInterval', 400);
  end

  %run simulated annealing on 1d trained model
  packed_model = pack2DHMM(tr1_guess, tr2_guess, em1_guess, em2_guess);
  %log start time
  begin = cputime;
  try
    trained_model = simulannealbnd(@(model, data)hmm_fitness(model, {seq1, seq2}), packed_model, [], [], options, logFile);
  catch exc
    display('WARNING: simulated annealing threw an exception')
    disp(getReport(exc))
    disp(exc)
    disp(exc.message)
    disp(exc.stack)
    disp(exc.identifier)
  end
  %log end time
  elapsed = cputime-begin;

  logL = -hmm_fitness(trained_model, {seq1, seq1});

  [tr1_trained, tr2_trained, em1_trained, em2_trained] = unpack2DHMM(trained_model);

